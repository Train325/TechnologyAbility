# 第二部分 自动内存管理机制
## 第2章 Java内存区域与内存溢出异常
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来

### 2.1 概述

### 2.2 运行时数据区域
![](../../static/timg.jpg)

#### 2.2.1 程序计数器（Program Counter Register）
程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### 2.2.2 Java虚拟机栈（Java Virtual Machine Stacks）
Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个`栈帧（Stack Frame）`，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了：
1. 编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）
2. 对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）
3. returnAddress类型（指向了一条字节码指令的地址）

64位长度的long和double类型的数据会占用2个局部变量空间（Slot）

局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常情况：
1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
2. 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

#### 2.2.3 本地方法栈（Native Method Stack）
本地方法栈则为虚拟机使用到的Native方法服务。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

#### 2.2.4 Java堆（Java Heap）
Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

Java堆是垃圾收集器管理的主要区域，因此很多时候被称为“GC堆”。

Java虚拟机规范：
* Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。

在实现时，既可以是固定的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展实现的（通过-Xmx和-Xms控制）。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

#### 2.2.5 方法区（Method Area）
方法区与Java堆一样，是各个线程共享的内存区域，用户存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

在HotSpot虚拟机上，也叫“`永久代`”，因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。

在JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。

Java虚拟机规范：
当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

#### 2.2.6 运行时常量池（Runtime Constant Pool）
运行时常量池是方法区的一部分。Class文件包含类的版本、字段、方法、接口等描述信息，还有常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池存放。

#### 2.2.7 直接内存（Direct Memory）
直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常。

JDK 1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

### 2.3 HotSpot虚拟机对象探秘


### 2.4 实战：OutOfMemoryError异常


## 第3章 垃圾收集器与内存分配策略








## 第4章 虚拟机性能监控与故障处理工具







## 第5章 调优案例分析与实战







































